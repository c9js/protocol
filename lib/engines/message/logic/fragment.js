/*▄────────────────────────────────────────────▄
  █                                            █
  █  Создает логику сборки исходных сообщений  █
  █                                            █
  ▀────────────────────────────────────────────▀*/
module.exports = class FragmentMessage {
/*┌─────────────┐
  │ Конструктор │
  └─────────────┘*/
    constructor(logic) {
    // Инициализируем логическую единицу
        logic(this);
        
    // Создаем список фрагментов для сборки исходного сообщения
        this.fragments = [];
    }
    
/*┌──────────────────────────────────────────────────────────┐
  │ Очищает список фрагментов для сборки исходного сообщения │
  └──────────────────────────────────────────────────────────┘*/
    clearFragments = () => {
        this.fragments = [];
    }
    
/*┌─────────────────────────────┐
  │ Собирает исходное сообщение │
  └─────────────────────────────┘*/
    assembleMessage = () => {
    // Декодируем список фрагментов в буфер исходного сообщения
        const messageBuffer = this.engine.decoder.decodeMessage(this.fragments);
        
    // Очищаем список фрагментов
        this.clearFragments();
        
    // Переводим буфер в исходное сообщение
        const message = this.engine.formatter.toMessage(messageBuffer);
        
    // Сообщаем о получении нового сообщения
        this.protocol.command.message(message);
    }
    
/*┌────────────────────────────────────────┐
  │ Добавляет фрагмент в список фрагментов │
  └────────────────────────────────────────┘*/
    addFragment = ({ FRAGMENT, isLast }) => {
    // Добавляем фрагмент в список фрагментов
        this.fragments.push(FRAGMENT);
        
    // Это последний фрагмент
        if (isLast) {
        // Собираем исходное сообщение
            this.assembleMessage();
        }
    }
};
