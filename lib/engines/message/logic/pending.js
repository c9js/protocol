/*▄─────────────────────────────────────────────────▄
  █                                                 █
  █  Создает логику очереди для отправки сообщений  █
  █                                                 █
  ▀─────────────────────────────────────────────────▀*/
module.exports = class PendingMessage {
/*┌─────────────┐
  │ Конструктор │
  └─────────────┘*/
    constructor(logic) {
    // Инициализируем логическую единицу
        logic(this);
        
    // Создаем очередь для отправки сообщений
        this.pending = [];
    }
    
/*┌────────────────────────────────────────┐
  │ Очищает очередь для отправки сообщений │
  └────────────────────────────────────────┘*/
    clearPending = () => {
    // Очищаем список фрагментов для сборки исходного сообщения
        this.engine.fragment.clearFragments();
        
    // Очищаем очередь для отправки сообщений
        this.pending = [];
    }
    
/*┌───────────────────────────────────────┐
  │ Проверяет наличие сообщений в очереди │
  └───────────────────────────────────────┘*/
    hasMessage = () => {
    // Проверяем наличие сообщений в очереди
        if (this.pending.length > 0) {
            return true;
        }
        
    // В очереди нет сообщений
        return false;
    }
    
/*┌──────────────────────────────────────────────────────┐
  │ Извлекает следующий пакет передачи данных из очереди │
  └──────────────────────────────────────────────────────┘*/
    extractNextPacket = () => {
    // Получаем первое сообщение из очереди
        const firstMessage = this.pending[0];
        
    // Получаем список пакетов передачи данных
        const dataPackets = firstMessage.dataPackets;
        
    // Извлекаем следующий пакет передачи данных
        const nextPacket = dataPackets[firstMessage.sendIndex];
        
    // Сохраняем инфориацию об отправлении пакета
        firstMessage.sendIndex++
        
    // Возвращаем следующий пакет передачи данных
        return nextPacket;
    }
    
/*┌──────────────────────────────┐
  │ Проверяет отправку сообщения │
  └──────────────────────────────┘*/
    checkMessageSent = () => {
    // В очереди нет сообщений
        if (!this.hasMessage()) return;
        
    // Получаем первое сообщение из очереди
        const firstMessage = this.pending[0];
        
    // В очереди еще есть не отправленные пакеты
        if (firstMessage.sendIndex < firstMessage.dataPackets.length) return;
        
    // Сообщение отправлено
        return true;
    }
    
/*┌───────────────────────────────────────────────────────────────┐
  │ Завершает процесс доставки последнего отправленного сообщения │
  └───────────────────────────────────────────────────────────────┘*/
    completeMessageDelivery = () => {
    // В очереди нет отправленных сообщений
        if (!this.checkMessageSent()) return;
        
    // Извлекаем отправленное сообщение из очереди
        const sentMessage = this.pending.shift();
        
    // Сообщаем о доставке сообщения
        this.protocol.command.delivered(sentMessage.message);
    }
    
/*┌──────────────────────────────────────────────────┐
  │ Добавляет новое сообщение в очередь для отправки │
  └──────────────────────────────────────────────────┘*/
    sendMessage = (message) => {
    // Переводим исходное сообщение в буфер
        const messageBuffer = this.engine.formatter.toBuffer(message);
        
    // Кодируем буфер исходного сообщения в список пакетов передачи данных
        const dataPackets = this.engine.encoder.encodeMessage(messageBuffer);
        
    // Добавляем новое сообщение в очередь для отправки
        this.pending.push({
            dataPackets: dataPackets, // Список пакетов передачи данных
                message:     message, // Исходное сообщение
              sendIndex:           0, // Индекс следующего пакета для отправки
        });
    }
};
